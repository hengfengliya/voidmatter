<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµå¼APIè¯¦ç»†æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .log {
            background: #000;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 15px;
            min-height: 400px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .success { color: #4ade80; }
        .error { color: #ef4444; }
        .warning { color: #f59e0b; }
        .info { color: #3b82f6; }
        .response { color: #a855f7; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ æµå¼APIè¯¦ç»†æµ‹è¯•</h1>

        <button onclick="testDetailedStream()">å®Œæ•´æµå¼å“åº”æµ‹è¯•</button>
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>

        <div>
            <h3>è¯¦ç»†æ—¥å¿—</h3>
            <div id="testLog" class="log">å‡†å¤‡å¼€å§‹è¯¦ç»†æµ‹è¯•...</div>
        </div>
    </div>

    <script>
        const CONFIG = {
            apiKey: '4dea1399-3986-471a-8f8c-b080f01fa103',
            baseURL: 'https://ark.cn-beijing.volces.com/api/v3',
            model: 'bot-20250915112813-kx2qr'
        };

        function log(message, type = 'info') {
            const logElement = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            const className = type;

            const logEntry = `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            logElement.innerHTML += logEntry;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function clearLog() {
            document.getElementById('testLog').innerHTML = 'æ—¥å¿—å·²æ¸…ç©º...\n';
        }

        async function testDetailedStream() {
            log('=== å¼€å§‹è¯¦ç»†æµå¼APIæµ‹è¯• ===', 'info');

            try {
                const requestData = {
                    model: CONFIG.model,
                    stream: true,
                    stream_options: {"include_usage": true},
                    messages: [
                        {
                            role: "system",
                            content: "You are a helpful assistant."
                        },
                        {
                            role: "user",
                            content: "è¯·ç®€å•ä»‹ç»ä¸€ä¸‹ä½ è‡ªå·±ï¼Œç”¨ä¸­æ–‡å›ç­”ã€‚"
                        }
                    ]
                };

                log(`å‘é€è¯·æ±‚åˆ°: ${CONFIG.baseURL}/bots/chat/completions`);
                log(`è¯·æ±‚æ•°æ®: ${JSON.stringify(requestData, null, 2)}`);

                const response = await fetch(`${CONFIG.baseURL}/bots/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                log(`å“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`âŒ è¯·æ±‚å¤±è´¥: ${errorText}`, 'error');
                    return;
                }

                log('âœ… å¼€å§‹æ¥æ”¶æµå¼æ•°æ®...', 'success');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let chunkCount = 0;
                let fullResponse = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        log('ğŸ æµå¼å“åº”å®Œæˆ', 'success');
                        break;
                    }

                    chunkCount++;
                    const chunk = decoder.decode(value, { stream: true });
                    log(`--- æ•°æ®å— ${chunkCount} (åŸå§‹) ---`, 'info');
                    log(chunk, 'info');

                    // è§£ææ¯ä¸€è¡Œ
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.trim() === '') continue;

                        log(`å¤„ç†è¡Œ: ${line}`, 'info');

                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);

                            if (data === '[DONE]') {
                                log('æ”¶åˆ°ç»“æŸæ ‡è®°: [DONE]', 'success');
                                continue;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                log(`è§£æçš„JSON: ${JSON.stringify(parsed, null, 2)}`, 'response');

                                const choice = parsed.choices?.[0];
                                if (choice) {
                                    if (choice.delta) {
                                        log(`Deltaå¯¹è±¡: ${JSON.stringify(choice.delta, null, 2)}`, 'response');

                                        if (choice.delta.content) {
                                            fullResponse += choice.delta.content;
                                            log(`ğŸ“ æ¥æ”¶å†…å®¹: "${choice.delta.content}"`, 'success');
                                        }

                                        if (choice.delta.thinking) {
                                            log(`ğŸ§  æ€ç»´å†…å®¹: "${choice.delta.thinking}"`, 'warning');
                                        }
                                    }

                                    if (choice.finish_reason) {
                                        log(`å®ŒæˆåŸå› : ${choice.finish_reason}`, 'info');
                                    }
                                }

                                if (parsed.usage) {
                                    log(`ä½¿ç”¨æƒ…å†µ: ${JSON.stringify(parsed.usage, null, 2)}`, 'info');
                                }
                            } catch (parseError) {
                                log(`âŒ JSONè§£æå¤±è´¥: ${parseError.message}`, 'error');
                                log(`åŸå§‹æ•°æ®: ${data}`, 'error');
                            }
                        }
                    }
                }

                log(`=== æµ‹è¯•å®Œæˆ ===`, 'success');
                log(`æ€»æ•°æ®å—: ${chunkCount}`, 'info');
                log(`å®Œæ•´å“åº”: "${fullResponse}"`, 'success');

                if (fullResponse === '') {
                    log('âš ï¸ è­¦å‘Š: æ²¡æœ‰æ¥æ”¶åˆ°ä»»ä½•å†…å®¹ï¼', 'warning');
                    log('å¯èƒ½çš„åŸå› :', 'warning');
                    log('1. æ¨¡å‹é…ç½®é—®é¢˜', 'warning');
                    log('2. APIå‚æ•°è®¾ç½®é—®é¢˜', 'warning');
                    log('3. æµå¼å“åº”æ ¼å¼å˜åŒ–', 'warning');
                }

            } catch (error) {
                log(`âŒ æµ‹è¯•å‡ºé”™: ${error.message}`, 'error');
                log(`é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'error');
            }
        }

        window.addEventListener('load', function() {
            log('ğŸš€ è¯¦ç»†æµ‹è¯•å·¥å…·å·²å¯åŠ¨', 'success');
        });
    </script>
</body>
</html>